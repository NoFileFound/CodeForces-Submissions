# Codeforces Submissions and Problem Categorization by Difficulty

## Overview
* This repository contains my Codeforces submissions (Primary in C++), categorized by tags to help you practice specific algorithms and data structures. By viewing this repository, you **AGREE** that you are not participating in any ongoing competition or virtual contest.

## Difficulty
* Problems are categorized into eight difficulty levels:
  * **1–2** — Easy  
  * **3–4** — Average  
  * **5–6** — Medium  
  * **7–8** — Hard

## Tags
* Some problems are categorized using one or more of the following tags:
* **2-SAT (2 Satisfiability)** — Problems involving boolean formulas with clauses of size two, usually solved using implication graphs and SCC.
* **Aliens** — Lagrangian Relaxation (Aliens trick) used to optimize problems with constraints by converting them into parameterized forms.
* **Bitmask** — Problems involving bitwise operations and bitwise masking.
* **Bruteforce** — Problems that require trying all possibilities due to small constraints.
* **Convex Hull Trick / Li Chao Tree** — Optimization techniques used to maintain a set of linear functions (convex functions).
* **Data Structures** — Usage of basic data structures such as stack, queue, deque, linked list, binary search trees (`set`, `map`, `multiset`), hash tables (`unordered_map`, `unordered_set`) and heaps (`priority_queue`).
* **Decomposition** — Techniques such as SQRT Decomposition, Heavy-Light Decomposition (HLD), and Centroid Decomposition.
* **Divide and Conquer** — Problems that split the problem into smaller subproblems and combine their results.
* **DSU** — Union-Find data structure, often used to track connected components.
* **DP** — Problems that require breaking down the solution into overlapping subproblems. (Dynamic programming)
* **FFT (Fast Fourier Transform)** — Algorithms used for fast polynomial multiplication and convolution.
* **Flows** — Maximum flow and minimum cut problems in flow networks.
* **Games** — Problems related to game theory, winning strategies, and optimal play.
* **Geometry** — Problems involving points, lines, distances, angles, and geometric properties.
* **Graphs** — Graph algorithms such as DFS, BFS, shortest paths, topological sorting, bridges, Euler cycles, Hamiltonian paths, and matchings.
* **Greedy** — Problems where locally optimal decisions lead to a globally optimal solution.
* **Hashing** — String hashing and polynomial hashing techniques for fast comparisons.
* **Interactive** — Interactive problems that require communication with the judge.
* **KMP** — String matching algorithms such as Prefix Function, Z-function, and Knuth–Morris–Pratt (KMP).
* **BigNum** — Problems involving very large numbers (greater than 10^18).
* **Math** — Problems involving mathematical concepts such as number theory, combinatorics, and modular arithmetic.
* **Meet in the Middle** — Technique that splits a problem into two halves to reduce complexity.
* **Persistent** — Persistent data structures that allow access to previous versions.
* **Prefix Sums** — Problems using cumulative sums for efficient range queries.
* **Randomization** — Randomized algorithms.
* **Searching** — Searching algorithms such as binary search, ternary search, linear search, and binary search on the answer.
* **ST** — Segment trees and related data structures including Fenwick Trees and Sparse Tables for range queries and updates.
* **Suffix Structures** — Advanced string data structures such as suffix array, suffix automaton, and suffix trees.
* **Treap** — Problems using the treap (tree + heap) data structure.
* **Trees** — Problems involving rooted trees and tree traversal techniques.
* **Trie** — Problems using the Trie (Prefix tree) data structure and its applications.
* **Two Pointers** — Two pointers technique for efficient array or string processing.
* **VT** — Virtual tree construction used to process queries on subsets of tree nodes efficiently.

## Credits
- ChatGPT for fixing my english grammar.